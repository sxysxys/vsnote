## 内存管理

- mmu：地址翻译，每一个cpu有一个。

- 页表：地址映射表，每一个进程有一个。

**多核cpu能跑多进程吗？**

<img src="操作系统记录.assets/截屏2020-12-31 10.19.09.png" alt="截屏2020-12-31 10.19.09" style="zoom:50%;" />

- 不能，一个cpu就算是多核也只对应了一个mmu，而一个mmu此时只能有一个页表，所以如果执行多个进程会发生内存映射的错误。

- 多cpu架构可以跑多进程，因为mmu不同，所以此时的页表可以不同。

## 调度问题

#### **线程是怎么调度的？**

调度程序是操作系统的底层实现，它也需要被cpu执行，当它切换到某个进程/线程的时候，会给当前进程/线程一个定时器，在定时中断的时候回到操作系统的调度程序中，再执行相应的调度算法。

#### **用户线程和内核线程**

>  用户线程的劣势和优势

优势：

- 可以自己实现调度算法，不需要进入内核，可以省去很多上下文切换的时间成本。
- 在用户态存一些线程的上下文，内核可以省去很多的空间。

劣势：

- 线程执行的时候不知道啥时候停止（不像操作系统分给进程的定时器），也就不能触发线程调度程序。
- 线程遇到一些阻塞型操作（例如io操作）的时候，会直接将进程阻塞，对操作系统而言，会直接调用别的进程。

#### 信号的概念

> 概念

- 信号不是一个普通的变量，而是操作系统通信的一种方式（包括实现互斥等）。
- 对中断的一种模拟，每当线程调度的时候会进行一次信号的处理。
- 可以理解为是操作系统级别的变量，在操作系统实现中对这些变量（信号）进行了相应的处理。

> 应用

- 锁、互斥的本质：底层一定是调用了操作系统的接口，将信号量送入，在接口中短暂的屏蔽了硬件中断，同时对信号量关联的相应的线程进行了一番操作（sleep等）。

- 进程的通信 -> 消费者生产者模型。

  up、down

  在这里面，信号主要是用于调用操作系统提供的接口时作为入参，关联相应的进程/线程，当某一个线程修改了相应的信号值后，操作系统能够在内核函数中通知与信号关联的其他线程（可能是一个对应信号的等待队列），从而对其他线程进行操作（包括从睡眠中唤醒等）。

- linux中的线程模型：pthread原理

- 信号在通信中的作用：键盘响应

  当键盘输入的时候，就会产生一个硬件中断，在中断处理中会传递相应的信号，而当线程重新调度的时候，会检测此时的信号量的情况，实现线程的通信。

#### 管程

> 概念

在同一时刻，管程中的程序只能被一个线程所调用，管程的出现更加能够保证程序运行的正确性。

> 应用

java中的synchronized，其实映射到操作系统中就是管程。

#### 消息传递和消息队列

> 概念

其实就是维护了一个信号类型的变量对应的一个队列，每当调用操作系统对应的某些接口函数（send、receive）的时候，就可以处理变量对应的消息队列元素。









































































