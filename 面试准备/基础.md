# 计算机网络

1. 7层模型简述，每层干什么，对应什么设备，每一层协议举例子。
2. 输入url对应的过程



### TCP

1. 报文格式，分别是干什么的  端口+发送包id+应答包id+数据偏移+几个状态位+窗口大小+数据
2. tcp三次握手
3. tcp四次挥手
4. 状态机：三次握手的信号SYN  ACK的使用；四次挥手信号FIN  ACK；  https://time.geekbang.org/column/article/8975
5. 顺序控制、超时重传策略（定时器和快速重传）
6. 窗口的几个部分：https://time.geekbang.org/column/article/9141  流量控制、拥塞控制；什么时候慢启动、什么时候快速重传
7. tcp brr算法解决的问题：不要等中间所有缓存设备都满了再进行拥塞控制，而是尽量保证高速度。
8. tcp如何保证可靠传输：就是tcp机制的总结
   1. 三次握手保证连接
   2. 端到端的检验和
   3. 收到数据会有ack应答，保证发送接受端都知道这个数据已经传输成功
   4. 顺序发送和超时重传：ARQ协议
   5. 流量控制和拥塞控制



### Socket与各种IO





### HTTP

1. 报文组成：请求行+请求头+正文

2. 常见请求头k-v

   1. Accept-Charset：客户端可以识别的字符集
   2. Content-Type：正文格式
   3. Connection:keep-alive  在1.1之后加入这个变成长连接
   4. Cache-control：主要用于缓存的场合，当http服务器（例如nginx）解析出max-age 指令时，如果判定缓存层中存在数据并且max-age比指定缓存时间小，那么就认为能够直接把缓存中的返回客户端，否则会请求应用服务器。

3. 常见状态码

   ![状态码](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E7%8A%B6%E6%80%81%E7%A0%81.png)

4. HTTP1.0：tcp短连接，每次http连接都要开一个新的tcp连接，非常耗时耗资源。

5. HTTP1.1：默认开启keep-alive，一次tcp能传多次http连接。

   1. 普通的tcp长连接：每次处理玩一个http连接才会处理下一个；只要一个阻塞，后面的都会受影响。
   2. pipeline模式：一个请求发送完毕后，无需等待响应，便可发送下一个请求。但是服务端响应的时候只能按照客户端发送请求的顺序进行响应，如果第一个请求处理特别慢，后面的请求即使处理完毕，也要等着，这就是著名的线头阻塞问题。

6. HTTP2.0

   1. 对http请求头进行一定的压缩，建立索引表，每次发头只要发索引即可。

   2. 一个tcp连接传输多个http连接的时候引入了流的概念，说白了就是之前http1.1的时候每次需要tcp把报文排好序传给应用层，所以需要按顺序来；而2.0的时候应用层可以负责对一个流id中的报文的顺序控制工作。

      ![img](https://static001.geekbang.org/resource/image/3d/d3/3da001fac5701949b94e51caaee887d3.jpeg)

7. HTTP3.0了解

8. 各个版本的对比：https://mp.weixin.qq.com/s/amOya0M00LwpL5kCS96Y6w

9. HTTP与HTTPS的区别：http://www.sxyniubi.xyz/archives/https%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B%E5%92%8C%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5



### MQTT

http://www.sxyniubi.xyz/archives/%E9%9D%A2%E8%AF%95mqtt%E7%90%86%E8%A7%A3



# 操作系统













