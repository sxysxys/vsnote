# Mysql面试复习

## sql基础

1. sql 执行顺序
   1. from
   2. join 
   3. on 
   4. where
   5. group by
   6. having
   7. select
   8. order by
2. having使用：其实是对group by后的组进行过滤操作。
3. in、exist区别：exist是外表作为驱动表，in是内表作为驱动表。
4. count(*)的使用：mysaim直接把行数存在了磁盘上，效率高；而InnoDB需要取出遍历计数
   1. 为什么innodb不像mysaim一样存行数呢？ 因为他基于多版本控制mvcc，必须确认这次查询所对应的行数。
   2. count(*)的优化，取最小的索引表遍历。
   3. 使用单独的计数表解决问题。
5. 各种count的区别：说白了就是innodb只对count(*)进行了优化，而其他的count都是server层要什么，innodb就给什么，server收到后，只要不为空就累加计数。count(1)就是把每行取出来，放一个1进去（不可能为null）。
6. 常见的sql语句：crud，创建表，创建索引，show语句，explain语句
7. varchar和char的区别：一个可变长度，一个是定长
8. 设计数据库是如何设计的。
   1. 数据库的第三范式：属性不依赖于非主属性，也就是属性不能有冗余。
   2. 不能过度的遵循第三范式，需要适度冗余，冗余一般用于查询多，但是更新少的场合。
   3. 大表进行分表。
   4. 大字段单独拆出去，例如博客表中的内容，在读取博客列表的时候不需要内容。
   5. 分库，读写分离。
   6. 索引，读的多的需要设计索引，遵循最左前缀原则。



## 高级基础

### mysql架构

1. 一个sql的执行流程

   连接器->缓存（看之前是否有查过，如果有直接返回）->分析器（分析语法）->优化器（对sql进行优化）->执行引擎-> 文件系统



### explain语句分析sql

1. explain的几个字段，字段表示的意思，具体见mind

   - id

   - select_type：此次查询的类型：如果没有子查询或者union等一般都是simple

   - table

   - type：此次查询用到的索引情况

     - system
     - const
     - eq_ref
     - ref
     - range
     - index
     - all

   - possible keys：可能使用的索引

   - key：实际使用的索引

   - key_len：索引的长度

   - rows：mysql估计的执行行数

   - extra：一些额外的信息

     > 几个重要的信息
     >
     > using fileSort：说明文件的排序字段没有走索引
     >
     > using temporary：使用临时表
     >
     > using index：好的指标，说明使用了覆盖索引
     >
     > using where：说明此时索引要回表
     >
     > using join buffer：使用了连接缓存

2. 如何分析explain？主要通过哪几个字段判断性能？  主要是type和extra



### 索引

1. 索引原理，几种索引

   - 主键索引：索引中存放了整行数据，也是聚簇索引
   - 非主键索引：存放的是主键id，所以当检索除id以外的数据时，需要回表。
   - 覆盖索引：索引直接覆盖了查询请求，无需回表；例如通过索引检索id，通过身份证和名字的联合索引，使用身份证检索姓名。
2. 几种原则：
   1. 最左前缀原则
   2. 索引下推优化
   3. 二级索引默认和主键联合索引
3. 自增主键为什么好：在插入的时候减少块的移动。
4. 索引的几种数据结构，为什么用b+树

   - 哈希：只能单值匹配
   - 有序数组：更新麻烦
   - 平衡二叉树：虽然效率高，但是索引要写入磁盘，io次数太多
   - b+树：N叉树，综合了效率和磁盘io
     - b树和b+树的区别

5. 优缺点：优点：排序查找，查找的时候增加了速度。缺点：占用空间、降低更新插入速度

6. 什么时候应该建立索引？

   - 多查询
   - order、group
   - 外键：使用join关联的时候，左关联时右表索引

7. 什么时候不用建立索引？

   - 表记录少
   - 经常改变的表
   - where用不上
   - 某一个数据多重复

8. 索引使用原则：尽量使用组合索引（最左前缀法则）

9. 索引失效的场景

   - 在组合索引中没有遵循最佳左前缀
   - 在索引列上做了函数、类型转换等操作
   - **组合索引中不能使用范围条件右边的索引**（指示了索引的原则）
   - 尽量使用覆盖索引（防止回表）
   - 使用!=、is not null符号会走全表扫描
   - like不遵守最佳左前缀法则
   - 字符串不加''导致索引失效（相当于做了转换）
   - 少用or，底层可能会使用all

10. 索引优化：

    1. 单表的话，使用联合索引时注意其中的范围查询，范围查询右边的索引会失效
    2. 关联表，要在被驱动表上加索引
    3. 子查询优化：小表驱动大表，exist in的用法和优化场景
    4. order by/group by优化，要尽量使用index，而不是filesort，也就是要遵循最佳左前缀原则
       - 如果迫不得已使用FILESORT，fileSort的单路和多路排序区别
    5. distinct关键词使用group by+索引优化
    
11. 普通索引和唯一索引在更新时候的区别：

    1. 唯一索引插入或者更新的时候，首先将相应页读出来，判断页中是否存在这个索引值，如果保证了唯一性，直接将数据插入内存中；

    2. 普通索引在更新的时候，为了保证效率（不需要判断重复性），他会直接将记录插入change buffer中。

       > change buffer：用来记录索引插入更新操作的，同步时机：当读相应页数据的时候，会触发merge操作同步持久化。



### Log日志/分析性能

1. 慢查询日志：默认关闭，通过`long_query_time`设置阈值，超过阈值就会加入log中，通过`mysqldumpslow`指令按条件检索log中的sql
2. Show Profile：分析最近执行语句的性能
3. redolog（重做日志）：提供了数据库`crash-safe`的能力，当数据库异常重启的时候，
   1. 当数据库更新、插入等操作时，如果每次都写数据耗时很长（需要将相应页读入内存、包括维护索引等），所以就采用了一种记账的方式，每次写redo log记录操作，在合适的时候（例如redolog文件满了，数据库此时空闲了等）将redolog中的东西刷入数据库表中。
   2. 数据结构：redolog是一组固定大小的，可以理解为一种环型结构，一个起始指针和一个末尾指针，当末尾指针追上起始指针了说明此时缓冲区满了，需要擦除操作。
4. binlog：主要是用于数据库的恢复、同步操作的。
5. 两阶段提交：
   1. 当事务完成后，先记录redo log prepare；再写binlog；再记录redo log commit，提交事务。
   2. 为什么要两阶段提交？ 保证binlog和redolog的一致性。
      - 如果先写redolog，再写binlog，当没来得及写binlog的时候数据库断了，数据库恢复后，会将redolog中的此次事务执行，但是在下次用binlog的时候，发现这个事务是不存在的，引入了不一致性。
6. 使用建议：redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。



### 引擎

1. myisam innodb区别，使用场景
   - myisam不支持事务
   - myisam不支持外键
   - innodb支持行锁
   - innodb支持redolog的异常恢复



### 锁/事务隔离级别

1. 事务概念：acid

   - 原子性：

     > 如何实现？
     >
     > 说白了就是事务出错的回滚机制，通过undo log实现。
     >
     > 在逻辑上，每一行数据都有相应的版本号，当指定了一个事务隔离级别后，每一行都有当前事务能看到的和不能看到的版本号集合；
     >
     > 在物理上，就是通过undo log实现的。

   - 一致性：通过redolog、binlog机制实现

   - 持久性：文件系统

   - 隔离性：mvcc

2. 脏读、幻读、不可重复读概念

   - 脏读：读到了别的还未提交的事务的数据
   - 不可重复读：同一事务内，两次读取数据不一致。
   - 幻读：同一事务内，第一次读到的数据数量和后面读到的不一样。

3. 事务的几种隔离级别，默认隔离级别：可重复读

   - 读未提交：啥都没解决
   - 读提交：解决了脏读
   - 可重复读：解决了不可重复读，没有解决幻读，幻读通过间隙锁解决。
   - 串行化：效率低

4. 隔离级别的具体实现（MVCC多版本并发控制）：

   - 每个事务一启动都会维护一个数组，记录此时系统中其他事务相对本事务的状态

   - 每行的更新后会对应一个事务版本号，当前事务执行时根据事务版本号判断是否允许读
   - 底层通过undo log实现（每一行数据都有相应的undolog回滚段）

5. 为什么不要用长事务（从隔离级别原理扯）

   1. 占用锁
   2. mvcc维护视图，占用undo log内存，因为当前事务可能访问此时数据库的任何表的任何一行，所以这些行数据的undo log需要一直保存；只有不执行事务的时候才会清除undo log。

6. 全局锁的应用场景，在支持事务的引擎中，进行全库逻辑备份

7. 表级锁的分类和应用，表锁和MDL

8. 行锁的两阶段提交

9. 行锁的死锁解决方法：设置等待时间和主动死锁检测

10. select 加锁 读锁 写锁，for update当前读

11. 幻读危害：不仅仅是读的危害，导致同步的不一致，出大问题。

12. next-key-lock（行锁+间隙锁）：

    1. 为什么要引入？解决幻读 https://time.geekbang.org/column/article/75659
    2. 使用原则：

    - 原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。

    - 原则 2：查找过程中访问到的对象才会加锁（如果只访问索引表，只会给索引表加锁）

      > lock in share mode 只锁覆盖索引，但是如果是 for update 就不一样了。 执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。

    - 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。

    - 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。

13. 如果没有索引，那么会此时行锁会升级为表锁，也就没有间隙锁的概念了。

14. mysql的乐观锁、悲观锁使用场景

    1. 悲观锁：读锁（lock in share mode）、写锁（update、for update等）都是悲观锁，注意加索引，否则变成表锁
    2. 乐观锁：通过在程序中加版本号实现



### 其他概念

1. join和join的优化：

   1. 优化器层面：正常执行的时候一般是先笛卡尔积，再on，最后结果再使用where；mysql优化器层面一般会先对sql进行where操作过滤一层，再进行join操作，优化后再把sql传给引擎。
   2. 在被驱动表有索引的时候，先把驱动表数据加载，一行一行去索引树中搜索。
   3. 在被驱动表没有索引的时候，采用了`Block Nested-Loop Join`算法进行优化，也就是不会每次都把驱动表的数据送入被驱动表中全表扫描，而是会把驱动表中的数据加载到join buffer中，然后把被驱动表的数据一行一行去和join buffer中的数据进行比较，这样就减小了大量的磁盘io。

   > 驱动表和被驱动表的选取
   >
   > left join、right join时驱动表分别是左表和右表；
   >
   > inner join此时会将小表作为驱动表，什么是小表？一般我们认为经过where等操作过滤后，行数少的表（如果行数一样，那么选检索字段少的表）。

   4. index join的优化：https://time.geekbang.org/column/article/80147  mrr bka的概念

2. sort buffer（fileSort时使用）：

   1. 当使用`fileSort`的时候，需要用到sort buffer进行排序。

      当需要排序的太多的时候（`sort buffer`设置的太小），此时会使用磁盘临时文件进行辅助排序。

   2. mysql对`fileSort`的优化，只需要把需要排序的字段和id放入sort buffer中，进行排序后再统一回表。

3. 什么时候用临时表

   例如使用group by的时候，例如要对`i % 10 == 0`的数据统计，这时候因为i % 10 == 0的满足条件的值不是有顺序的，后面可能还有，所以需要使用临时表存储。

4. 自增id如何实现：基于自增锁实现，mysql5.1引入了`innodb_autoinc_lock_mode`参数

   - `innodb_autoinc_lock_mode`值对应关系：

     0：每次事务结束才释放锁。

     1：普通insert，执行完直接释放；批量插入，当批量执行完才释放（为什么要这样？防止binlog同步时候的id不一致）。

     2：普通insert和批量insert都是每次都是执行完释放。

     > 为什么自增id不连续？
     >
     > 事务回滚等原因。

   - 配置：我们一般将binlog配置为row，`innodb_autoinc_lock_mode`设置为2，保证并发的同时，也能使得数据一致性得到保证

   - 自增id的版本问题：

     - 在8.0之前，自增id此时的大小是保存在内存中的，每次重启mysql都会从表中读取最后一行写入内存；
     - 8.0之后：写redo log持久化。

     

   

### 主从复制

通过binlog

















