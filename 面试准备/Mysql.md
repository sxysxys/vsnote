# Mysql面试复习

## sql基础

1. sql 执行顺序
2. having使用
3. in、exist区别：exist是外表作为驱动表，in是内表作为驱动表。
4. count(*)的使用：mysaim直接把行数存在了磁盘上，效率高；而InnoDB需要取出遍历计数
   1. 为什么innodb不像mysaim一样存行数呢？ 因为他基于多版本控制mvcc，必须确认这次查询所对应的行数。
   2. count(*)的优化，取最小的索引表遍历。
   3. 使用单独的计数表解决问题。
5. 各种count的区别：说白了就是innodb只对count(*)进行了优化，而其他的count都是server层要什么，innodb就给什么，server收到后，只要不为空就累加计数。count(1)就是把每行取出来，放一个1进去（不可能为null）。
6. 常见的sql语句：crud，创建表，创建索引，show语句，explain语句
7. varchar和char的区别：一个可变长度，一个是定长
8. 设计数据库是如何设计的。
   1. 数据库的第三范式。
   2. 不能过度的遵循第三范式，需要适度冗余，冗余一般用于查询多，但是更新少的场合。
   3. 大表进行分表。
   4. 大字段单独拆出去，例如博客表中的内容，在读取博客列表的时候不需要内容。
   5. 分库，读写分离。
   6. 索引，读的多的需要设计索引，遵循最左前缀原则。



## 高级基础

### mysql架构

1. 一个sql的执行流程

   连接器->缓存（看之前是否有查过，如果有直接返回）->分析器（分析语法）->优化器（对sql进行优化）->执行引擎-> 文件系统

### explain语句分析sql

1. explain的几个字段，字段表示的意思，具体见mind
2. 如何分析explain？主要通过哪几个字段判断性能？

### 索引

1. 索引原理，几种索引

   - 主键索引：索引中存放了整行数据，也是聚簇索引
   - 非主键索引：存放的是主键id，所以当检索除id以外的数据时，需要回表。
   - 覆盖索引：索引直接覆盖了查询请求，无需回表；例如通过索引检索id，通过身份证和名字的联合索引，使用身份证检索姓名。

2. 几种原则：最左前缀原则，索引下推优化，二级索引默认和主键联合索引

3. 自增主键为什么好：在插入的时候减少块的移动。

4. 索引的几种数据结构，为什么用b+树

   - 哈希：只能单值匹配
- 有序数组：更新麻烦
   - 平衡二叉树：虽然效率高，但是索引要写入磁盘，io次数太多
- b+树：N叉树，综合了效率和磁盘io
   - b树和b+树的区别
   
5. 优缺点：优点：排序查找，查找的时候增加了速度。缺点：占用空间、降低更新插入速度

6. 什么时候应该建立索引？

   - 多查询
   - order、group
   - 外键：使用join关联的时候，左关联时右表索引

7. 什么时候不用建立索引？

   - 表记录少
   - 经常改变的表
   - where用不上
   - 某一个数据多重复

8. 索引使用原则：尽量使用组合索引（最左前缀法则）

9. 索引失效的场景

   - 在组合索引中没有遵循最佳左前缀
   - 在索引列上做了函数、类型转换等操作
   - **组合索引中不能使用范围条件右边的索引**（指示了索引的原则）
   - 尽量使用覆盖索引（防止回表）
   - 使用!=、is not null符号会走全表扫描
   - like不遵守最佳左前缀法则
   - 字符串不加''导致索引失效（相当于做了转换）
   - 少用or，底层可能会使用all

10. 索引优化：

    1. 单表的话，使用联合索引时注意其中的范围查询，范围查询右边的索引会失效
    2. 关联表，要在被驱动表上加索引
    3. 子查询优化：小表驱动大表，exist in的用法和优化场景
    4. order by/group by优化，要尽量使用index，而不是filesort，也就是要遵循最佳左前缀原则
       - 如果迫不得已使用FILESORT，fileSort的单路和多路排序区别
    5. distinct关键词使用group by+索引优化
11. 普通索引和唯一索引在查询和更新时候的区别：change buffer



### log日志/分析性能

1. 慢查询日志：默认关闭，通过`long_query_time`设置阈值，超过阈值就会加入log中，通过`mysqldumpslow`指令按条件检索log中的sql
2. Show Profile：分析最近执行语句的性能
3. redolog binlog的区别
4. redolog的执行流程、binlog执行流程，何时执行
5. 为什么两阶段提交：保证安全

### 引擎

1. myisam innodb区别，使用场景
   - myisam不支持事务
   - myisam不支持外键
   - innodb支持行锁
   - innodb支持redolog的异常恢复

### 锁/事务隔离级别

1. 事务概念：acid
2. 脏读、幻读、不可重复读概念
3. 事务的几种隔离级别，默认隔离级别
4. 隔离级别的具体实现（MVCC多版本并发控制）：每行的更新后会对应一个事务版本号，当前事务执行时根据事务版本号判断是否允许读
5. 为什么不要用长事务（从隔离级别原理扯）
6. 全局锁的应用场景，在支持事务的引擎中，进行全库逻辑备份
7. 表级锁的分类和应用，表锁和MDL
8. 行锁的两阶段提交
9. 行锁的死锁解决方法：设置等待时间和主动死锁检测
10. 并发事务的问题：脏读、幻读、不可重复读、丢失更改
11. 脏读、幻读、不可重复读和隔离级别的关系
12. select 加锁 读锁 写锁，for update当前读
13. 幻读危害：不仅仅是读的危害，导致同步的不一致，出大问题。
14. 间隙锁的概念，为什么要引入？解决幻读 https://time.geekbang.org/column/article/75659
15. 如果没有索引，那么会此时行锁会升级为表锁
16. mysql的乐观锁、悲观锁使用场景

### 其他概念

1. sort buffer  join buffer
2. 什么时候用临时表
3. 自增id如何实现

### 主从复制



















