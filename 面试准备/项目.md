# 项目问题

## 种子追溯

> 1. 介绍项目

项目背景：

种子追溯系统，这个项目总的来说分为两个部分，一个是生产端，一个是服务端，首先我们管理员登陆服务器后台去进行产码，将产出的码给到生产端，生产端这边通过印码机印到包装上，然后将这些产品放到传送带上一个个去扫，把码通过串口扫到工控机里面去，这个工控机是个c#客户端，他对这些传过来的码进行一个校验，打包操作，导出一个txt文件，这些码就是经过扫描即将入库的码，生产端这块就是这样。

接下来服务端的入库模块就会解析这个txt文件，将这些码进行一个个入库，存到数据库里，关联上入库信息，对库存进行一个更改。当某个地方的经销商要货的时候，这个时候就进行一个出库操作，通过pda扫描要出库的大袋码，输入经销商信息，通过接口传给服务器，服务器这边存码的出库信息，减库存这些。

接下来消费者就可以通过扫二维码的方式请求我们服务器去查看这个商品的所有入库出库信息。我们的管理员登陆后台去查看统计模块，消费者在哪扫码的啊，库存这些信息。

整个流程就是这样，这个项目技术的话springboot+mybatis，前端就是用基础的bootstrap写的。我主要负责的就是入库模块，产码，追溯查询这块。



> 2. 分表，为什么分表

- 一个公司表的数据多了，首先查询会变慢，有很多联合查询。
- 维护索引这些也会变困难。



> 3. 大数据插入问题

- 大数据量插入，一开始选择循环一条一条插入，太慢了。
- 批量插入，sql语句太长报错。
- 循环批量插入，一次插1000行，insert delay。
- 看spring事务和mybatis，完成多线程插入功能，通过CountDownLatch完成同步，为什么多线程插入事务不回滚。



> 4. 多线程插入的时候线程池如何配置

- 因为每次插入的任务是一段数据，首先一定要确保此次插入不会丢数据，所以拒绝策略一定不能选那个直接丢弃，如果拒绝了抛出了异常，那么用户下次肯定还是把这批数据导入进来，还是会报异常，所以拒绝策略就选择那个`CallerRunsPolicy`。
- 由于这个操作是属于io密集性操作，**corePoolSize = CPU核数 \* 2**
- max和core一样，队列长度要尽量保证不要进入拒绝策略。



> 5. 查询优化

- 追溯sql优化，加覆盖索引，原先连表太多，拆分成入库和出库两次查询执行。

- 单表索引优化，查看慢查询日志看，` orderby usingfilesort `  、> 号没有遵循最左前缀原则。
- 联表优化：在一些后台的展示产品库存的场景下使用：https://time.geekbang.org/column/article/80147  Batched Key Access



> 6. 条码号唯一如何实现

原先使用的是`new Random()`配合时间戳的方式，当并发场景下，由于时间戳一样，会生成重复码。

后来改成了使用时间戳+原子递增数的方式，由于在重置原子数的时候不是原子操作，在高度并发下还是有可能生成重复码。

<font color=red>雪花算法：</font>其实如果不是在分布式场景下，不适用机器id+机房id的方式区分，他也是时间戳+递增数的方式，只不过他每次产生数的时候会加锁，并且在高并发下（一个时间戳超过4096的情况下），会使用自旋的方式去等待时间戳，保证了高并发下数据的唯一性。

**为什么不用uuId**

1. 对数据库索引不友好。
2. UUID太长了。

**为什么不用userId**

因为有可能同一时刻有两个用户登录。



> 7. 单机版的权限管理、登录如何实现

1. radb模型，5张表。
2. 登录通过shiro配置拦截器放过`/login`，然后在调用`subject.login()`方法，进入`userRealm`的认证方法中进行认证并且向shiro中注册相应session。
3. 下一次访问的时候会通过前端的cookie(包含用户id、jessionId等)经过一系列过滤器（在shiroConfig中配置）认证后，关联上后端session，再看到一些`@hasPermission`注解后进入授权逻辑，去数据库取出这个用户的权限参数来判断是否有权限，每个用户的所有信息都是存在shiro的session缓存中。



> 8. 数据库表是如何实现的

按着数据库设计来说。





## agv调度后台

>  1. 介绍项目

项目背景：

医院agv调度系统，整个系统都是围绕mqtt服务器的。我们系统中的其他部分都是mqtt client。mqtt基于发布订阅，我们客户端只要订阅相应主题就能收到信息。mqtt client主要部分一个就是小车车体工控机，它是一个基于qt写的客户端，主要是通过slam技术去扫描地图，还有就是联网将小车信息封装成mqtt协议发送接收，直接通过串口驱动小车。

还有车载app，它需要获取数据直观在车上显示。

另外一个部分就是我们的调度后台，每次后台springboot一启动就会开一个mqtt client线程去连mqtt server收发数据。后台分为几个部分，首先就是建筑物、地图，目标点这些的基本模块管理；首页大屏显示，就是把mqtt收到的数据通过ws推送到前端openlayers医院地图上展示。最主要的核心就是这个任务模块，他的大体流程就是医护人员或者物流派发人员通过在前端页面新建任务，选择目标点，任务紧急程度，agv型号这些信息，点击下发就加入一个优先队列里面。mqtt client这个线程接收小车车体信息，只要是空闲状态，就取出队列中的任务元素，根据小车信息和目标点进行动态最短路径的生成，将这个路线的点链成一个链表，收到小车到达某个点的消息，将指针置到下一个点，发下一个点，直到任务结束，在任务执行过程中前端也可以随时点击取消任务。总的来说我们这个后台就是要保证每个任务的顺利调度和顺利结束。



> 2. 为什么用mqtt

为什么使用mqtt协议：看博客，与rabbitmq对比。



>  3. agv发送任务的逻辑

- 如何保证并发修改下的数据同步问题。
- 手写阻塞队列和优先级阻塞队列。
- 逻辑：小车空闲的时候发送任务



> 4. 并发问题

mqtt client线程 read是单线程的，必须保证这个线程不堵塞，需要配置线程池进行io操作： 数据库  发送mqtt

**任务下发：**

下发是由小车发送空闲驱动的，但是小车空闲不代表他一定能接任务，他可能会出现一些状况，不接这个任务，甚至有可能因为的网络的问题很久都没收到这个任务，所以设置了一个主题接受任务响应，小车如果能接受到任务，并且他此时也能执行任务，他就会回我这个响应，我此时再将小车和任务进行绑定。

场景：当同时有很多个小车发送空闲的时候，之前就出现过可能是mqtt服务器那边堵了还是怎么，突然一瞬间大量空闲灌进来。

会导致的问题：由于我们的mqtt读线程不能堵，此时所以我们必须要通过异步的方式下发任务，那么就有可能很多车都peek出了队列头的任务进行下发，这样就会导致很多车都绑定上了这个任务，这就会出大问题。

<font color=red>解决方法：</font>

我们先是在异步发送任务前先给队列中的第一个任务加标志位，就算此时去异步发送任务了，此时其他车发任务前一看这个置了标志位了，就不会发送了；但是如果说这个接受任务的小车没有接这个任务，那么队列中第一个任务标志位一直是1，那么永远下发不下去。

此时使用了juc包下的`sychroousQueue`解决了这个问题，我在下发任务的时候对这个queue进行offer操作进行一个wait 5s钟，如果接受线程那边收到了此任务的下发任务响应，那么会poll操作，此时offer操作返回true，再将任务移除队列；如果他不会poll，说明此时车体没有下发任务响应，说明车那边此时无法接受任务，此时offer返回false，再将队列第一个元素标志位置回0，这样其他车体便可以绑定任务了。



> 5. 生成路线部分， dijiastra算法，链表生成路线，手写算法，如何避免环路。

**几个数据结构：**

1. 在启动服务器的时候，此时维护一个有向图数据结构，里面存放了一些边和标志物的id。

2. 在启动服务器的时候，此时维护了一个Map，将所有mark对象加载进mark。
3. 再生成路线的时候，此时通过dijiastra算法找到了一个最短路径，将map中的mark外面套了一个双向链表进行连接起来了，作为一个全局的map，key是路线的起始点和终点，val是路线的起始点mark。
4. 如果有任务的目标点的key和全局map中的key相等，此时直接就用全局map产生的route。
5. 还有一个map，用来记录每辆车执行到了哪个点上了，key是车的info，val是链表中的某个点。



>  6. 两车相撞，如何保证不撞。

由于使用的是指针，去的时候小车信息会记录去的状态，到达目标点之后此时小车状态改变为回的状态，在小车到达目标点之后，会判断有没有小车和自己方向是相反的，并且他下一个目标点就是自己现在到的位置，并且他上一个点是我们小车下一个点要去的位置，如果有这种情况，就原地等待，直到另一个小车先过去再走。



>  7. 小车mqtt连接异常判断，mqtt断线重连。

**为什么要判断小车异常状态：**

因为很多东西是无状态的，例如小车的充电桩，一旦小车状态异常无法正常上传数据，此时服务器需要维护这些无状态的物体的状态，在小车断开连接的时候需要及时置位操作。

**如何断线检测：**

使用mqtt的will机制，客户端断线，全体通知，此时会进行对一些状态的置位操作。









## 课堂项目

> 1.  介绍项目



> 2. 分布式的权限控制、登录如何实现

数据库依旧是radb模型。

**url请求**

采用jwt的方式，不依赖于服务端的session。

首先是将登录请求转发给授权服务器，通过授权服务器进行验证后生成一个jwt（userId、roleId、过期时间等），将用户的权限信息在登录成功后存入redis，在后来每次访问端口经过网关的时候携带jwt，（需要去授权服务器拿公钥）对用户信息进行jwt验证，只要对了就说明认证成功；再进入授权管理器，在授权管理器中拿到此时的roleId，去redis中去验证此时的url和roleId的对应关系，看是否能完成授权。

>  进阶的话使用整合oauth认证的方式：先配置授权服务器，在请求的时候通过系统可以信任的clientId、clientSecreat等过滤，再验证登录后，生成jwt，里面有用户信息，包括accessToken、refreshToken，下次请求网关（资源服务器的时候），通过accessToken去验证此时经过认证，再经过授权管理器去操作。

**一些路由、按钮的渲染：**

- 在单机版项目中，由于所有的权限参数信息都存放在用户的session中，此时可以直接通过服务端渲染引擎（thymeleaf等）在渲染时直接取得此次连接的session用户域，通过`hasPer`等标签在用户域中进行渲染。
- 但是在分布式、前后端分离项目中，由于是不使用session的方式，此时根据权限的渲染工作主要就交给前端了，在登录成功请求权限menu的时候，根据userId和roleId将相应的menu返回，很多是否渲染的逻辑主要就是在前端持久化后自行判断了。

**退出登录：**

如果是普通的session方式，直接让session失效即可。

如果是普通的jwt方式，jwt是不会失效的，所以此时可以在redis里去配置黑名单，在过滤器中判断一下redis的黑名单即可。



**jwt的优缺点：**

jwt优点：

1.  无需在服务器存放用户的数据（session），减轻服务器端压力。如果在分布式下还使用传统的session，那么需要session复制，非常耗费资源。

2.  轻量级、json风格比较简单。

3.  在前后端分离中，可以给前端一些用户的明文数据随时查阅。
4.  可以配合oauth使用。

缺点：

Token一旦生成后期无法修改：

1.  无法更新token有效期

2.  无法销毁一个token

使用场景：一般使用在前后端分离项目和分布式项目中。

签名算法：RS256：非对称加密，HS256：对称加密。



> 3. OSS云推送，静态资源存储的几种方式

1. 先注册阿里云的oss，拿到相应的key和secret。
2. 使用`inputStream`进行推送。



> 4. 支付模块和第三方登录模块





## 通用问题

1. 数据库表的设计思路















