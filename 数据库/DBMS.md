## DBMS组成
![](/截图/截屏2020-03-2011.36.46.png)
- 接口负责接收sql，通过odbc、用户直接输入等。
- Paeser负责检查语法错误，生成语法树。
- Grant checking负责检查用户权限，是否有权进行操作。
- ddl、ql等负责全面解释sql操作。
- access management负责将表的相应操作转换为真正的物理数据结构操作。也就是关系模型概念与物理存储结构的映射关系。

## 几种访问模式
1. 单用户单进程：直接将dbms和应用程序链接到一个可执行文件中。
2. 多用户多进程：每次应用需要访问数据库的接口的时候，都会创建一个dbms进程。这样做的坏处就是每创建一个进程都会消耗相应的系统资源。
3. 多用户多线程：使用一个dbms进程创建多个线程。
   ![](/截图/截屏2020-03-2013.31.33.png)

## 物理层
作用：将对关系模型的访问具体到对物理对象的访问。

#### 分类
1. 查询的元组数量大于关系的15%
2. 查询特定的某一个元组
3. 查询的数量在15%以下
4. 更新
5. 插入

#### 物理层文件的数据结构
- 堆文件：存的时候直接放文件最后面堆；查询的时候只有扫描。1分类很适合用这种。
- 哈希：适合2分类。
  - 哈希函数（索引）：将表中的某一个字段的每一个值进行哈希函数的计算，生成不同的值，将这些值放入数组中，分别指向相应的元组（如果碰到相同的数据那么数组的一个值关联多个元组）；优点是当查找2分类时非常迅速。缺点是当要关联大量数据时需要进行多次io操作，性能不好；并且当查询的一个数据有多个相等的元组时，也需要进行多次io操作。总的来说缺点多于优点。
- 堆文件 + b+树索引：存取按照堆的形式存，然后在关键字段建立一个b+树索引（b+树的节点存这条数据的地址）。当需要大量的查找（1分类）的时候，使用堆文件直接扫描的方法；如果需要进行2分类的查找，使用b+树索引。<font color=red>但是索引不是越多越好，因为每对一个属性建立索引，在数据发生变化的时候都需要去维护。</font>
- 动态哈希
- 栅格文件

#### raw disk管理文件
- 目的：将数据集中，而不是分散到磁盘的各个地方。从而读取数据的时候提高效率。
- 概念：是os的一种功能。比os的文件系统更底层的一种文件管理方法，能够决定数据存放的位置。
- 簇集索引：当在数据库设计的时候，发现需要频繁的对一个属性进行操作，可以将这个属性通过raw disk建成一个簇集（按顺序放在同一个磁道上，以后查询就不需要移动机械臂），以提高效率。这种方式本身就是对这个属性进行了一个物理上的索引。

## 查询优化
- 为了解决什么问题：查询时，当10000个元组的关系和50000个元组的关系进行联结的时候，笛卡尔乘积需要进行500000000次，而且由于磁盘碎块的关系，可能执行一个小时都查不完。效率太低了。
- 基本步骤：先将用户输入的sql进行优化成效率较高的形式，再通过具体的索引和文件格式进行查询；并且实现要尽量减少系统开销。
- 简单的例子:多表联结查询
    ![](/截图/截屏2020-03-2016.09.27.png)
  - 代数优化：将查询树优化，形式上的优化
    - 尽量将一元操作（如选择、投影这种操作）先执行，这样减少二元或多元（笛卡尔积）的运算量。
    ![](/截图/截屏2020-03-2016.09.18.png)
    - 每次选择完后将一些对下面的操作没有关系的属性投影掉，只保留下面要用到的属性。
  - 操作优化：形式上优化完后，在对这个形式进行实现的时候具体怎么优化；例如联结的运算等。
    - 联结操作（ 一般常见的表联结操作，s.pid=p.qid相等取出）的实现：
      - 此时如果使用二重嵌套查询，将每一个pid往qid里带，此时限制的主要瓶颈在于磁盘的读写时间；由于磁盘是块设备，我们可以取一个块（1024bit）的s关系元组放在内存缓冲区中，再开启一个块的内存缓冲区用于存放p的元组；直接用第一个内存缓冲区这一个块的元组和取出的p的元组去比。这样减少了非常多的io时间（加入一个块能存10个元组，那么就减少了10*10=100倍的io时间，尽管算法逻辑没改进）。<br>方法扩展：假设开辟了n个内存缓冲区，把1个给内循环，n-1个给外循环，这样能最大化减少io操作。但是申请的缓冲区越多，内存占用就越多。
      - 归并扫描：直接按pid和qid进行磁盘中的顺序存放。
      - 假设内循环的qid有索引，那么直接将外循环的块加载进内存，取出相应属性去内循环的索引中匹配即可。
      - 通过哈希实现连接，属性相等的通过哈希函数后值也相等。一般用于联结属性很少更新的时候。

#### 概念
- 查询树：语法树进行优化后的树
  - 叶子：代表了一个关系
  - 中间的节点：代表了一元或者二元操作
  - 叶子到根的顺序就是dbms执行的顺序。
- 运算关系的等价变换规则：书283，转化为对树的操作。
  - `π`：投影
  - `σ`：选择
  - `⋈`:连接（笛卡尔积x选择）
  - `X`:笛卡尔积

## 恢复
- 作用：防止系统出现故障。如果出现故障，需要dbms对数据进行恢复。例如读写突然停电，需要将数据一致性恢复。

#### 实现条件
- 冗余是必须的（数据的备份）
- 需要监测到所有可能的故障

#### 一些概念
- 周期备份：完整备份之间结合增量转储。
- 备份结合日志：日志中记录了自从上次备份以来数据的所有变化。当出现问题的时候，使用这种手段恢复，日志相当于把之前用户的操作重演了一遍。
- 事务原子性：定义一个transation，dbms负责维护。
  ![](/截图/截屏2020-03-2108.51.18.png)
  如果不对数据库指定事务，那么一条sql就是一个事务。
- 日志需要记录每一个事务所对应的物理块数据的变化。一般是文本，不会是链表。
  ![](/截图/截屏2020-03-2109.03.33.png)

#### 具体操作
不同的数据库的实现策略是不一样的，拿提交来举例。（BID为before，AID为after）
1. 在提交之前就将ai写入了db，这时提交其实不用干什么事了。
   ![](/截图/截屏2020-03-2109.35.32.png)
   当出了意外以后，此时每次dbms启动都会进行检查(重启动模块)。
    |  commit list   | active list  | 操作 |
    |  ----  | ----  |---- |
    |   无   | 有   | undo |
    |有 | 有| 把tid从activelist删除|
    | 有| 无| 啥也不管，已经成了|
2. ai->db after commit
    |  commit list   | active list  | 操作 |
    |  ----  | ----  |---- |
    |   无   | 有   | 直接将tid从active删除|
    |有 | 有| redo，ai->db|
    | 有| 无| 啥也不管，已经成了|
3. ai->db concurrently with commit:后台开启一个线程，每次磁盘空闲的时候将日志中的ai写入db，充分利用磁盘资源。
   ![](/截图/截屏2020-03-2110.25.41.png)
      |  commit list   | active list  | 操作 |
    |  ----  | ----  |---- |
    |   无   | 有   | undo |
    |有 | 有| redo|
    | 有| 无| 啥也不管，已经成了，开机后继续搬就完事了|

## 并发
- 由于操作系统会对dbms的每一个事务进行调度，当系统对dbms事务的任意调度方式和事务的某一种串行执行结果是一致的话，那么就说明执行结果是正确的。也就是说n个事务可能产生的正确的结果有n!种。并发控制
也就是控制的这个。

#### 并发控制的解决方案
- 多米诺效应：当多个事务并发执行的时候，当某个事务执行了一个更新操作，然后被另一个事务抢占了cpu，这个事务对更新的数据进行了读写操作；当cpu执行权回到第一个事务的时候，执行的时候发现出错了，dbms便会对此事务进行回滚，此时第二个事务也得跟着回滚，这就是多米诺效应。
- 封锁法：只要对数据对象进行操作就加锁，不管什么操作。
  ![](/截图/截屏2020-03-2119.40.52.png)
  - 左边这种2PL（对某个用到的关系操作完了再释放锁，也就是保证后面的语句不再用到这个关系了就释放锁）是能保证串行效果的；右边的不行。
  - 当使用左边这种，并且在对需要写的数据关系的锁在事务执行完的时候才释放，那么这样能有效的避免事务出错时候的多米诺效应。
  - 当使用左边这种，并且对所有关系（不管读写）都要等到事务结束再释放锁，那么这种就称为严格的2PL，但这样用户体验不好，效率较低。
- SX锁协议：读写的锁区分开来（S锁：共享锁；X锁：排他锁）:S锁可以同时进行，X锁不能。这样能够使dbms的效率明显提高，用户体验好。
- SUX锁协议（U锁：只能读不能写）：因为有时候更新操作的时候，我们需要先将数据先读出来再写；可以在读的期间不必加X锁，先加个U锁，这时候被调度了还能让其他的事务见缝插针读一下，写的时候再加X锁。
    ![](/截图/截屏2020-03-2120.21.05.png)

#### 死锁
概念：和操作系统的死锁概念一样，解决死锁分为两大类方法：避免死锁和解决死锁。
- 超时法：当某一个数据资源很久都在等待，那么系统默认它发生了死锁。
- 使用图这种数据结构，将每个事务作为一个顶点，把事务之间申请资源当做图的边，当图中出现了环路就说明系统发生了死锁。当出现死锁的时候，kill掉一个回滚代价最小的事务。
- 避免死锁：操作系统的方法在数据库中都不适用。数据库中适用的方法：
    - 对每一个事务定义两个属性：一个是tid（事务号），一个是建立时间，当发生请求锁资源时，比较这两个建立时间，如果请求的比占用的年轻，那么请求的事务自己kill掉自己，一段时间后再以原来的建立时间重新启动；如果请求的比占用的老，那么就进行等待锁资源。
      - 由于只有老的请求年轻的，所以不会产生死锁；而且年轻的虽然总被kill，它终有一天变成老的，也就不会产生活锁（饿死）。
    - 年老碰到年轻锁，直接kill年轻；和上个方法性质一样。

   
   