# 关系型数据库的用户接口和sql
## interface
在关系型数据库系统中，dbms给用户和应用程序开发人员提供了接口以访问数据库。有以下几种接口：
1. sql语言
2. gui图形化操作界面
3. 应用程序的api（odbc、jdbc）
4. 应用程序的类库

## 查询select
```sql
Select [distinct] 1 from 2 where 3 group by 4 having 5
1. 查询的字段
2. 查询的表集合
3. 条件
```
步骤：
1. 将表拼接成一个笛卡尔乘积
2. 对3中的条件进行筛选
3. 筛选完后通过groupby进行分组，将属性相同的进行分组
4. having以组为单位进行检查筛选
5. 进行1的投影，此时1中也是以组为单位执行的（如果执行min、sum这种都是以组为单位执行的），此时select里出现的属性必须是单一的（groupby的值）。
![关联查询](/截图/截屏2020-03-0119.40.25.png)
6. 如果[]需要去重的话，重新排列去重。

*要注意，having和select中出现的属性必须要在groupby出现，要不然数据库会报错，一些数据库的函数除外。*<br>

*实际的dbms中如果按上面这样做的话效率太低，会进行一些优化。*

两张表可以只要满足表结构一样，可以使用`union`来进行合并。<br>
两张表可以只要满足表结构一样，可以使用`except`来进行相减。<br>
两张表可以只要满足表结构一样，可以使用`intersect`来进行相交。

#### 关联嵌套查询（重要）
![关联查询](/截图/截屏2020-03-0116.20.38.png)
其中Exists代表true or false<br>
相当于一个二重循环，要把S表中的字段带进R表中进行匹配。<br>
精髓:将表S中一个值括号里的值里去，完了以后看是否添加到输出中，添加完不会立刻输出，会将所有都遍历完了以后再输出。

[多层嵌套关联查询](https://blog.csdn.net/mtawaken/article/details/6573122?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)<br>
精髓:先把里面那层全部查完了，才会去搞外面。

#### 非关联嵌套查询
![非关联查询](/截图/截屏2020-03-0116.20.53.png)
先将括号里的完成后相当于做了一张表，然后再在这个表中进行操作。效率高。

#### 查询的一些基本操作
- COUNT(*):表记录的个数
- COUNT([DISTINCT]A)    //DISTINCT就是去重计算
- SUM([DISTINCT]A):和
- AVG([DISTINCT]A):平均
- MAX(A)
- MIN(A)

#### NULL值问题
有时候查询的属性里面有null值，需要注意筛选。

## SQL的新特性
- CAST：将属性进行强制类型转换
  - 在函数中为了匹配形参属性
  - 给某一不存在的列看做null，对null进行强转，使得某一个字段满足运算要求（并兼容、差兼容）
  ![学生和军人合并例子](/截图/截屏2020-03-0219.42.15.png)
  - 改变属性的精度
- Case：对查出结果的替换操作
  ![学生和军人合并例子](/截图/截屏2020-03-0219.50.13.png)
  当查出数字的时候分别替换成sql中的字符串。
  ![例子](/截图/截屏2020-03-0220.17.24.png)
- 子查询Sub-query
  - 标量子查询<br>
    子查询查出来的是一个值。所以只要在sql中，能够出现一个val的地方，都能出现一段标量子查询代码块。
    - ![例子](/截图/截屏2020-03-0220.30.25.png)
        每个d关系连接到下面。
    - ![例子](/截图/截屏2020-03-0220.34.33.png)
        正常查，只不过把查出来的一个属性弄到另一个sql里去了
  - 表表达式<br>
    出现在from子句后面。
  - 公共表表达式：防止做出来的子表(表表达式)多次执行
    ![公共表防止执行两次](/截图/截屏2020-03-0220.52.35.png)
    做出了一张公共表payroll，防止让子表查询执行两次。
- 外连接outer-join
  ![先做公共表，再进行联合就是外连接](/截图/截屏2020-03-0309.47.44.png)
    先做出了公共表，再将这些公共表进行联合(并)就是外连接。
- 递归查询<br>
  如果公共表表达式的在他的定义中使用了它自己，就会进行递归。
  - ![递归1](/截图/截屏2020-03-0309.57.26.png)
  - ![递归2](/截图/截屏2020-03-0310.01.27.png)
    ```sql
    //不管是递归还是子查询，思路都是先把子表做出来。
    with wingpart(subpart,qty) as (select subpart,qty from Components where Part='wing') 
    union (select c.subpart,c.Qty*w.Qty from Components c,winpart w where c.part=w.subpart) 
    //将子表中的rivet加起来。
    Select sum(qty) from wingpart where subpart='rivet'
    ```
    *上面两个例子都是无环的，不需要对递归设置终止条件，而有时候模型是有环的，需要对递归的语句设置终止条件，递归能够让sql有基本的推理能力。*
## 删除、更新、添加
## sql视图
实表和虚表：实表是实际存在数据库中的，虚表是实表的一个视图（查询关联结果），它表本身是不存在于数据库中的，但是虚表的定义会存在数据库中。

实表和虚表进行对应：
![是否支持视图更新](/截图/截屏2020-03-0314.23.50.png)
上面的支持，因为没有做什么计算，仅仅做了投影和选择；而下面的就不行了，无法映射回原表。

## 嵌入式sql
应用程序中访问数据库有哪些问题？<br>
- 程序设计语言中的变量和sql表之间的结合匹配。
- 应用程序语言和dbms之间的匹配。
- sql和编程语言之间属性的匹配。

解决方法：
- 嵌入式sql
- 编程语言api
  - ODBC：定义了数据库函数的接口，每个数据库厂家对接口进行不同的实现。便于应用程序移植。
- 类库

嵌入式sql的执行过程：
```flow
st=>start: 含有嵌入式sql的主语言程序
e=>end: 可执行文件
op1=>operation: DBMS的预编译器将嵌入式sql链接成相应的库函数，
库函数由数据库产商提供，此时的源代码变成了纯C代码
op2=>operation: C编译器处理
st->op1->op2->e
```
#### 动态sql
先通过scanf得知用户想要的信息，进行sql字符串的拼接，拼接完了以后将字符串放入exec中。思路就是嵌入式sql的思路，只不过不是指定的sql，需要对sql进行拼接处理后再送入嵌入代码块中。

## 存储过程
把需要执行的一系列sql经编译和优化后放入数据库中，以后需要进行类似的逻辑操作的时候不用自己去写sql语句了，只要CALL这一段sql并填入相应参数就行了。<br>

好处：
1. 运行效率高，不用做重复劳动，节省dbms编译哟优化的时间。
2. 方便企业，不同程序员做同一个业务逻辑的时候不用单独编写sql了，直接引用这一段存储过程即可；并且当这个业务逻辑需要修改的时候，只要改存储过程里的就行了，不用所有sql都改。




   


  
  







